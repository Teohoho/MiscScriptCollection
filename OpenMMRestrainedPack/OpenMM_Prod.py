from simtk.openmm.app import *
from simtk.openmm import *
from simtk.unit import *
from sys import stdout
import numpy as np
import datetime

import argparse
parser = argparse.ArgumentParser()
parser.add_argument("--files", type=str, help="Roots of files you want to Min,Heat,Equi; needs to be formatted like files.prmtop and files.inpcrd")
parser.add_argument("--OutputRoot", type=str, help="A string to be appended to the begining of the DCD,OUT,CHK and XML files generated by openMM")
parser.add_argument("--LoadState", type=str, help="XML file from previous simulation. Optional")
args = parser.parse_args()

def GenerateRestraint(Positions, Indices):

	"""A function that generates an OpenMM Force object given
	   a set of positions and a list of atom indices that said 
	   force must affect.

	Parameters
   ----------

	Positions: simtk.unit.quantity.Quantity
		list of positions used in setting up the harmonic restraints

	Indices: list of int
		list of atom indices that will be affected by the force generated

	Returns
	------

	GeneratedRestraint: simtk.openmm.openmm.CustomExternalForce
		harmonic potential force object

	"""

	CustomHarmonicForce = CustomExternalForce("springConstant * (periodicdistance(x, y, z, x0, y0, z0)^2)")     #Keep periodicity in mind?
	CustomHarmonicForce.addGlobalParameter("springConstant", (10)*kilocalories_per_mole/nanometer**2)
	CustomHarmonicForce.addPerParticleParameter("x0")
	CustomHarmonicForce.addPerParticleParameter("y0")
	CustomHarmonicForce.addPerParticleParameter("z0")
	
	for PartIx in Indices:
		PartX = Positions[PartIx][0].value_in_unit(nanometer)
		PartY = Positions[PartIx][1].value_in_unit(nanometer)
		PartZ = Positions[PartIx][2].value_in_unit(nanometer)
		
		CustomHarmonicForce.addParticle(PartIx, [PartX, PartY, PartZ])


	print ("A new restraint was generated, containing {} atoms.".format(len(Indices)))
	
	return CustomHarmonicForce


# Read files
prmtop = AmberPrmtopFile(args.files + ".prmtop")
inpcrd = AmberInpcrdFile(args.files + ".inpcrd")

# Thermodynamics
T = 300*kelvin
p = 1*bar
timestep = 0.002*picoseconds

# First we create the system, context, simulation objects
system = prmtop.createSystem(nonbondedMethod=PME, nonbondedCutoff=1*nanometer, constraints=HBonds)
system.addForce(MonteCarloBarostat(p, T))
#system = prmtop.createSystem(implicitSolvent=OBC2, soluteDielectric=1.0, solventDielectric=80.0, nonbondedMethod=CutoffNonPeriodic, nonbondedCutoff=1.2*nanometer, constraints=HBonds, implicitSolventSaltConc=0.15*moles/liter)

integrator = LangevinIntegrator(T, 1/picosecond, timestep)

platform = Platform.getPlatformByName('CUDA')
properties = {'DeviceIndex': '0,1'}
simulation = Simulation(prmtop.topology, system, integrator, platform, properties)

# Load previous positions and velocities
# First we need to instantiate the force object
# so the spring constant found in the constrained
# minimization done before can be assigned

system.addForce(GenerateRestraint())
simulation.loadState(args.LoadState)

# We then remove the empty force object
system.removeForce(system.getNumForces()-1)

# Production
nofSteps = 500000000 #(1000 ns)
dcdFreq  = 50000 #(10000 frames) 
outFreq  = 1000 #(500000 lines)
rstFreq  = 1000000
print("Production run for " + str(nofSteps * timestep))
print("Simulation started at " + str(datetime.datetime.now()))

simulation.reporters.append(StateDataReporter("{}_Prod.out".format(args.OutputRoot), outFreq, step=True,
                              potentialEnergy=True, kineticEnergy=True, totalEnergy=True, temperature=True,
                              density=True, separator="\t"))
simulation.reporters.append(DCDReporter("{}_Prod.dcd".format(args.OutputRoot), dcdFreq)) ##200 frames
simulation.reporters.append(CheckpointReporter("{}_Prod.chk".format(args.OutputRoot), rstFreq))

simulation.step(nofSteps)
simulation.saveState(args.OutputRoot + 'Final.xml') #We save it, since we may want to continue this simulation.
simulation.saveCheckpoint(args.OutputRoot + "Final.chk") #We also save a checkpoint, if we want to continue this simulation later.
print("Done at " + str(datetime.datetime.now()))


