from simtk.openmm.app import *
from simtk.openmm import *
from simtk.unit import *
from sys import stdout
import numpy as np
import datetime

import argparse
parser = argparse.ArgumentParser()
parser.add_argument("--files", type=str, help="Roots of files you want to Min,Heat,Equi; needs to be formatted like files.prmtop and files.inpcrd")
parser.add_argument("--OutputRoot", type=str, help="A string to be appended to the begining of the DCD,OUT,CHK and XML files generated by openMM")
parser.add_argument("--LoadState", type=str, help="XML file from previous simulation. Optional")
parser.add_argument("--RestrainedAtomsIn", type=str, help="A file containing the indices of the atoms to be restrained")
args = parser.parse_args()

## In order to reinitialize the restraints to the new positions
## of the particles, we need to generate the force objects as we 
## go. I will write a function that takes a set of positions and 
## a set of indices and returns a force object.

def GenerateRestraint(Positions, Indices):

	"""A function that generates an OpenMM Force object given
	   a set of positions and a list of atom indices that said 
	   force must affect.

	Parameters
   ----------

	Positions: simtk.unit.quantity.Quantity
		list of positions used in setting up the harmonic restraints

	Indices: list of int
		list of atom indices that will be affected by the force generated

	Returns
	------

	CustomHarmonicForce: simtk.openmm.openmm.CustomExternalForce
		harmonic potential force object

	"""

	CustomHarmonicForce = CustomExternalForce("springConstant*(periodicdistance(x, y, z, x0, y0, z0)^2)")     #Keep periodicity in mind?
	CustomHarmonicForce.addGlobalParameter("springConstant", (10)*kilocalories_per_mole/angstrom**2)
	CustomHarmonicForce.addPerParticleParameter("x0")
	CustomHarmonicForce.addPerParticleParameter("y0")
	CustomHarmonicForce.addPerParticleParameter("z0")

	if (Positions is not None) and (Indices is not None):
		for PartIx in Indices:
			PartX = Positions[PartIx][0].value_in_unit(nanometer)
			PartY = Positions[PartIx][1].value_in_unit(nanometer)
			PartZ = Positions[PartIx][2].value_in_unit(nanometer)
			
			CustomHarmonicForce.addParticle(PartIx, [PartX, PartY, PartZ])


	print ("A new restraint was generated, containing {} atoms.".format(CustomHarmonicForce.getNumParticles()))
	
	return CustomHarmonicForce

# Read files
prmtop = AmberPrmtopFile(args.files + ".prmtop")
inpcrd = AmberInpcrdFile(args.files + ".inpcrd")

# Thermodynamics
T = 300*kelvin
p = 1*bar
timestep = 0.002*picoseconds

# First we create the system, context, simulation objects
system = prmtop.createSystem(nonbondedMethod=PME, nonbondedCutoff=1*nanometer, constraints=HBonds)
system.addForce(MonteCarloBarostat(p, T))
#system = prmtop.createSystem(implicitSolvent=OBC2, soluteDielectric=1.0, solventDielectric=80.0, nonbondedMethod=CutoffNonPeriodic, nonbondedCutoff=1.2*nanometer, constraints=HBonds, implicitSolventSaltConc=0.15*moles/liter)

integrator = LangevinIntegrator(T, 1/picosecond, timestep)

platform = Platform.getPlatformByName('CUDA')
properties = {'DeviceIndex': '0,1'}

simulation = Simulation(prmtop.topology, system, integrator, platform, properties)

# Load previous positions and velocities
# First we need to instantiate the force object
# so the spring constant found in the constrained
# minimization done before can be assigned

system.addForce(GenerateRestraint())
simulation.loadState(args.LoadState)

# We then remove the empty force object
system.removeForce(system.getNumForces()-1)

# We iterate through all the sets of restraints, creating a list
# of all the index groups

FlexList  = open(args.RestrainedAtomsIn) 
LoopAtoms = FlexList.read().split("\n") 
LoopAtoms = [x for x in LoopAtoms if x]  ##Remove empty elements 

for RestraintIx in range(len(LoopAtoms)):
	LoopAtoms[RestraintIx] = LoopAtoms[RestraintIx].split()   ##Split into n groups
	LoopAtoms[RestraintIx] = [int(x) for x in LoopAtoms[RestraintIx] if x]  ##Turn to ints


print ("There are {} restraint profiles:".format(len(LoopAtoms)))
for RestraintIx in range(len(LoopAtoms)):
	print ("\t· Restraint Set {}: {} atoms restrained out of a total of {} atoms.".format(RestraintIx, len(LoopAtoms[RestraintIx]),system.getNumParticles()))

##Heat
##We have to heat the system while iterating through all the constraints set.

##We add reporters

for RestraintIx in range(len(LoopAtoms)):
## We need to remove the old restraint, if it exists.
## It corresponds to the last force object

	simulation.reporters = []
	
	simulation.reporters.append(StateDataReporter("{}_HeatingRestraintProfile{}.out".format(args.OutputRoot, RestraintIx), 1000, step=True,
											potentialEnergy=True, kineticEnergy=True, totalEnergy=True, temperature=True,
											density=True, separator="\t"))
	simulation.reporters.append(DCDReporter("{}_HeatingRestraintProfile{}.dcd".format(args.OutputRoot, RestraintIx), 6000)) ##200 frames/restraint profile

	CurrentPositions = simulation.context.getState(getPositions=True).getPositions()
	AtomIndices = LoopAtoms[RestraintIx]

##Add Restraint
	CurrentRestraint = GenerateRestraint(CurrentPositions, AtomIndices)

	system.addForce(CurrentRestraint)	
	simulation.context.reinitialize(preserveState=True)

##Heating, for 1ns, just to be safe.
	for T in range(5,300,10):
		print ("Heating to {}K…".format(T))
		integrator.setTemperature(T)
		simulation.step(35000)
##Equilibrating, for 0.75 ns
	print ("Equilibrating…")
	simulation.step(750000)

##Remove Restraint
	system.removeForce(system.getNumForces()-1)

##Global heating & Eq

simulation.context.reinitialize(preserveState=True)

simulation.reporters = []
simulation.reporters.append(StateDataReporter("{}_HeatingGlobal.out".format(args.OutputRoot, RestraintIx), 1000, step=True,
										potentialEnergy=True, kineticEnergy=True, totalEnergy=True, temperature=True,
										density=True, separator="\t"))
simulation.reporters.append(DCDReporter("{}_HeatingGlobal.dcd".format(args.OutputRoot, RestraintIx), 6000)) 


for T in range(5,300,5):
	print ("Heating globally to {}K…".format(T))
	integrator.setTemperature(T)
	simulation.step(20000)

print ("Equilibrating globally…")
simulation.step(600000)

##Save Coords
SaveState = simulation.context.getState(getPositions=True)
pdbWrite = pdbreporter.PDBReporter("{}_PostHeating.pdb".format(args.OutputRoot), reportInterval=0)
pdbWrite.report(simulation, SaveState)

##Save State
simulation.saveState("{}_PostHeating.xml".format(args.OutputRoot))
