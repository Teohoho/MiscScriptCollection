from simtk.openmm.app import *
from simtk.openmm import *
from simtk.unit import *
import sys

import OpenMM_RestraintGenerator as ommr

import argparse
parser = argparse.ArgumentParser()
parser.add_argument("--files", type=str, help="Roots of files you want to Min,Heat,Equi; needs to be formatted like files.prmtop and files.inpcrd")
parser.add_argument("--Solvent", type=str, help="What type of solvent to use. Possible values: explicit OR implicit.")
parser.add_argument("--OutputRoot", type=str, help="A string to be appended to the begining of the DCD,OUT,CHK and XML files generated by openMM")
parser.add_argument("--LoadState", type=str, help="XML file from previous simulation. Optional")
args = parser.parse_args()

if (version.short_version <= "7.2"):
	print ("Your version of OpenMM ({}) doesn't have the latest form of the 'reinitializeContext' method." \
"Please update to versions higher than 7.2".format(version.short_version))

if (args.OutputRoot is None):
	args.OutputRoot = args.files.split("/")[-1]

## FILE READ ## 
prmtop = AmberPrmtopFile(args.files + ".prmtop")
inpcrd = AmberInpcrdFile(args.files + ".inpcrd")

## THERMO PARAMS SET ## 
T = 300*kelvin
p = 1*bar
timestep = 0.002*picoseconds

## SYSTEM SET ##
if (args.Solvent.lower() == "explicit"):
	system = prmtop.createSystem(nonbondedMethod=PME, nonbondedCutoff=1.2*nanometer, constraints=HBonds)
	system.addForce(MonteCarloBarostat(p, T))

elif (args.Solvent.lower() == "implicit"):
	system = prmtop.createSystem(implicitSolvent=OBC2, soluteDielectric=1.0, solventDielectric=80.0, nonbondedMethod=CutoffNonPeriodic, nonbondedCutoff=1.2*nanometer, constraints=HBonds, implicitSolventSaltConc=0.15*moles/liter)

else:
	print ("No valid solvent type was selected. Exiting...")
	sys.exit()

## SIMULATION SET ##
integrator = LangevinIntegrator(T, 1/picosecond, timestep)
simulation = Simulation(prmtop.topology, system, integrator)
print ("System Generated!")

##	If loading a state, we need to instantiate a force	object
##	so the system knows about the spring constant

rest = ommr.GenerateRestraint(HarmonicIndices="HarmonixFile.rstr") 
DummyForce = rest.HarmonicRestraint(simulation, dummy=True)
system.addForce(DummyForce)
simulation.context.reinitialize(preserveState=True)

if (args.LoadState) is None:
	simulation.context.setPositions(inpcrd.positions)
	if inpcrd.boxVectors is not None:
		simulation.context.setPeriodicBoxVectors(*inpcrd.boxVectors)
else:
	simulation.loadState(args.LoadState)

system.removeForce(system.getNumForces()-1)

## Initialize Restraint Object ##
rest = ommr.GenerateRestraint(HarmonicIndices="HarmonixFile.rstr") 

## Go through heating protocol
for RestIx in range(len(rest.HarmonicList)):

	simulation.reporters = []
	simulation.reporters.append(StateDataReporter("{}_HeatingRestraintProfile{}.out".format(args.OutputRoot, RestIx), 1000, 
											step=True, potentialEnergy=True, kineticEnergy=True, 
											totalEnergy=True, temperature=True, density=True, separator="\t"))

	simulation.reporters.append(DCDReporter("{}_HeatingRestraintProfile{}.dcd".format(args.OutputRoot, RestIx), 6000)) ##200 frames/restraint profile	

	RstForce = rest.HarmonicRestraint(simulation, rest.HarmonicList[RestIx], Periodic=True)
	system.addForce(RstForce)
	simulation.context.reinitialize(preserveState=True)

	##Heating, for ~1ns, just to be safe.
	for T in range(5,300,10):
		print ("Heating to {}K...".format(T))
		integrator.setTemperature(T)
		simulation.step(17000)
	##Equilibrating, for 0.75 ns
	print ("Equilibrating...")
	simulation.step(375000)
	
	##Remove Restraint
	system.removeForce(system.getNumForces()-1)

	SaveState = simulation.context.getState(getPositions=True)
	pdbWrite = pdbreporter.PDBReporter("{}_Restraint{}.pdb".format(args.OutputRoot, RestIx), reportInterval=0)
	pdbWrite.report(simulation, SaveState)


## Heat Globally	##	
simulation.reporters = []
simulation.reporters.append(StateDataReporter("{}_HeatingGlobal.out".format(args.OutputRoot), 1000, step=True,
										potentialEnergy=True, kineticEnergy=True, totalEnergy=True, temperature=True,
										density=True, separator="\t"))
simulation.reporters.append(DCDReporter("{}_HeatingGlobal.dcd".format(args.OutputRoot), 6000)) 


for T in range(5,300,5):
	print ("Heating globally to {}K...".format(T))
	integrator.setTemperature(T)
	simulation.step(20000)

print ("Equilibrating globally...")
simulation.step(600000)

## Save PDB	##
SaveState = simulation.context.getState(getPositions=True)
pdbWrite = pdbreporter.PDBReporter("{}_PostHeating.pdb".format(args.OutputRoot), reportInterval=0)
pdbWrite.report(simulation, SaveState)

##	Save CheckPoint	##
simulation.saveState("{}_FinalMinimization.xml".format(args.OutputRoot))
