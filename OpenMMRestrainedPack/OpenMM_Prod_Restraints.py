from simtk.openmm.app import *
from simtk.openmm import *
from simtk.unit import *
from sys import stdout
import numpy as np
import datetime

import argparse
parser = argparse.ArgumentParser()
parser.add_argument("--files", type=str, help="Roots of files you want to Min,Heat,Equi; needs to be formatted like files.prmtop and files.inpcrd")
parser.add_argument("--Solvent", type=str, help="What type of solvent to use. Possible values: explicit OR implicit.")
parser.add_argument("--OutputRoot", type=str, help="A string to be appended to the begining of the DCD,OUT,CHK and XML files generated by openMM")
parser.add_argument("--LoadState", type=str, help="XML file from previous simulation. Optional")
args = parser.parse_args()

if (version.short_version <= "7.2"):
	print ("Your version of OpenMM ({}) doesn't have the latest form of the 'reinitializeContext' method." \
"Please update to versions higher than 7.2".format(version.short_version))

if (args.OutputRoot is None):
   args.OutputRoot = args.files.split("/")[-1]
	
# Read files
prmtop = AmberPrmtopFile(args.files + ".prmtop")
inpcrd = AmberInpcrdFile(args.files + ".inpcrd")

# Thermodynamics
T = 300*kelvin
p = 1*bar
timestep = 0.002*picoseconds

# First we create the system, context, simulation objects
if (args.Solvent.lower() == "explicit"):
	system = prmtop.createSystem(nonbondedMethod=PME, nonbondedCutoff=1.2*nanometer, constraints=HBonds)
	system.addForce(MonteCarloBarostat(p, T))
elif (args.Solvent.lower() == "implicit"):
	system = prmtop.createSystem(implicitSolvent=OBC2, soluteDielectric=1.0, solventDielectric=80.0, nonbondedMethod=CutoffNonPeriodic, nonbondedCutoff=1.2*nanometer, constraints=HBonds, implicitSolventSaltConc=0.15*moles/liter)
else:
	print ("No valid solvent type was selected. Exiting...")
	sys.exit()

integrator = LangevinIntegrator(T, 1/picosecond, timestep)
simulation = Simulation(prmtop.topology, system, integrator)

# Load previous positions and velocities
# First we need to instantiate the force object
# so the spring constant found in the constrained
# minimization done before can be assigned

rest = ommr.GenerateRestraint(HarmonicIndices="HarmonixFile.rstr") 
DummyForce = rest.HarmonicRestraint(simulation, dummy=True)
system.addForce(DummyForce)

if (args.LoadState) is None:
	simulation.context.setPositions(inpcrd.positions)
	if inpcrd.boxVectors is not None:
		simulation.context.setPeriodicBoxVectors(*inpcrd.boxVectors)
else:
	simulation.loadState(args.LoadState)

# We then remove the empty force object
system.removeForce(system.getNumForces()-1)

nofSteps = 250000000 #(500 ns) 
dcdFreq  = 25000 #(10000 frames) 
outFreq  = 500 #(500000 lines)
rst1Freq  = 10000
rst2Freq  = 25000

## Go through production protocol ##
for RestIx in range(len(rest.HarmonicList)):

	simulation.reporters = []
	simulation.reporters.append(StateDataReporter("{}_Prod_Restraint{}.out".format(args.OutputRoot, RestraintIx), outFreq, step=True,
	                           potentialEnergy=True, kineticEnergy=True, totalEnergy=True, temperature=True,
	                           density=True, totalSteps=nofSteps, remainingTime=True, speed=True, progress=True, separator="\t"))
	simulation.reporters.append(DCDReporter("{}_Prod_Restraint{}.dcd".format(args.OutputRoot, RestraintIx), dcdFreq)) 
	simulation.reporters.append(CheckpointReporter("{}_Prod_01_{}.chk".format(args.OutputRoot,RestraintIx), rst1Freq))
	simulation.reporters.append(CheckpointReporter("{}_Prod_02_{}.chk".format(args.OutputRoot,RestraintIx), rst2Freq))

	RstForce = rest.HarmonicRestraint(simulation, rest.HarmonicList[RestIx], Periodic=True)
	system.addForce(RstForce)
	simulation.context.reinitialize(preserveState=True)
	
	simulation.step(nofSteps)
	
	##Remove Restraint
	system.removeForce(system.getNumForces()-1)

	SaveState = simulation.context.getState(getPositions=True)
	pdbWrite = pdbreporter.PDBReporter("{}_Restraint{}.pdb".format(args.OutputRoot, RestIx), reportInterval=0)
	pdbWrite.report(simulation, SaveState)

##	Do a global production run	##
simulation.reporters = []
simulation.reporters.append(StateDataReporter("{}_Prod_Restraint{}.out".format(args.OutputRoot, "_Global"), outFreq, step=True,
                           potentialEnergy=True, kineticEnergy=True, totalEnergy=True, temperature=True,
                           density=True, totalSteps=nofSteps, remainingTime=True, speed=True, progress=True, separator="\t"))
simulation.reporters.append(DCDReporter("{}_Prod_Restraint{}.dcd".format(args.OutputRoot, "_Global"), dcdFreq)) 
simulation.reporters.append(CheckpointReporter("{}_Prod_01_{}.chk".format(args.OutputRoot,"_Global"), rst1Freq))
simulation.reporters.append(CheckpointReporter("{}_Prod_02_{}.chk".format(args.OutputRoot,"_Global"), rst2Freq))

simulation.step(nofSteps)
