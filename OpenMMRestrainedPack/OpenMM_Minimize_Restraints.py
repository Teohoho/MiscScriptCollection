from simtk.openmm.app import *
from simtk.openmm import *
from simtk.unit import *
import sys

import OpenMM_RestraintGenerator as ommr

import argparse
parser = argparse.ArgumentParser()
parser.add_argument("--files", type=str, help="Roots of files you want to Min,Heat,Equi; needs to be formatted like files.prmtop and files.inpcrd")
parser.add_argument("--Solvent", type=str, help="What type of solvent to use. Possible values: explicit OR implicit.")
parser.add_argument("--OutputRoot", type=str, help="A string to be appended to the begining of the DCD,OUT,CHK and XML files generated by openMM")
parser.add_argument("--LoadState", type=str, help="XML file from previous simulation. Optional")
args = parser.parse_args()

if (version.short_version <= "7.2"):
	print ("Your version of OpenMM ({}) doesn't have the latest form of the 'reinitializeContext' method." \
"Please update to versions higher than 7.2".format(version.short_version))

if (args.OutputRoot is None):
	args.OutputRoot = args.files.split("/")[-1]

## FILE READ ## 
prmtop = AmberPrmtopFile(args.files + ".prmtop")
inpcrd = AmberInpcrdFile(args.files + ".inpcrd")

## THERMO PARAMS SET ## 
T = 300*kelvin
p = 1*bar
timestep = 0.002*picoseconds

## SYSTEM SET ##
if (args.Solvent.lower() == "explicit"):
	system = prmtop.createSystem(nonbondedMethod=PME, nonbondedCutoff=1.2*nanometer, constraints=HBonds)
	system.addForce(MonteCarloBarostat(p, T))

elif (args.Solvent.lower() == "implicit"):
	system = prmtop.createSystem(implicitSolvent=OBC2, soluteDielectric=1.0, solventDielectric=80.0, nonbondedMethod=CutoffNonPeriodic, nonbondedCutoff=1.2*nanometer, constraints=HBonds, implicitSolventSaltConc=0.15*moles/liter)

else:
	print ("No valid solvent type was selected. Exiting...")
	sys.exit()

## SIMULATION SET ##
integrator = LangevinIntegrator(T, 1/picosecond, timestep)
simulation = Simulation(prmtop.topology, system, integrator)
print ("System Generated!")

simulation.context.setPositions(inpcrd.positions)
if inpcrd.boxVectors is not None:
	simulation.context.setPeriodicBoxVectors(*inpcrd.boxVectors)

TotalPotEnergy = simulation.context.getState(getEnergy=True).getPotentialEnergy().value_in_unit(kilocalories_per_mole)
print ("Before any minimization is done, the energy is {} kcal/mole".format(TotalPotEnergy))

## RESTRAINED MINIMIZATION START ##
## Initialize Restraint Object ##

rest = ommr.GenerateRestraint(HarmonicIndices="HarmonixFile.rstr") 

## Go through minimization protocol
for RestIx in range(len(rest.HarmonicList)):

	RstForce = rest.HarmonicRestraint(simulation, rest.HarmonicList[RestIx], Periodic=True)
	system.addForce(RstForce)
	simulation.context.reinitialize(preserveState=True)

	simulation.minimizeEnergy()

	TotalPotEnergy = simulation.context.getState(getEnergy=True).getPotentialEnergy().value_in_unit(kilocalories_per_mole)
	print ("After minimization number {} the energy is {} kcal/mole".format(RestIx,TotalPotEnergy))

	system.removeForce(system.getNumForces()-1)
	simulation.context.reinitialize(preserveState=True)	

	SaveState = simulation.context.getState(getPositions=True)
	pdbWrite = pdbreporter.PDBReporter("{}_Restraint{}.pdb".format(args.OutputRoot, RestIx), reportInterval=0)
	pdbWrite.report(simulation, SaveState)


print ("Minimizing Globally...")
simulation.context.reinitialize(preserveState=True)
simulation.minimizeEnergy()
TotalPotEnergy = simulation.context.getState(getEnergy=True).getPotentialEnergy().value_in_unit(kilocalories_per_mole)
print ("After global minimization the energy is {} kcal/mole".format(TotalPotEnergy))
SaveState = simulation.context.getState(getPositions=True)
pdbWrite = pdbreporter.PDBReporter("{}_NoRestraint.pdb".format(args.OutputRoot), reportInterval=0)
pdbWrite.report(simulation, SaveState)

simulation.saveState("{}_FinalMinimization.xml".format(args.OutputRoot))
